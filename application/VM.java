package application;


import java.util.Arrays;
import virtualmachine.*;


/** Simple VM implementing a complete virtual machine.
 *
 * This class implements the machine control interface, the state interface,
 * register interface and memory interface of a virtualmachine.
 * There is also simple debug output available.
 * */
public class VM implements VirtualMachine, MachineState, RegisterFile, Memory
{
	/** Mark pointer of the VM.
	 * */
	protected int mp;


	/** Stack pointer of the VM.
	 * */
	protected int sp;


	/** Programm counter of the VM.
	 * */
	protected int pc;


	/** Memory as simple byte array.
	 * */
	protected byte[] memory;


	/** Instructions are stored in a different storage array.
	 * */
	protected Instruction[] code;


	/** Flag to indicate if there is progress.
	 * */
	protected boolean hangs;


	/** Enable or disable debug output for every step.
	 * */
	protected boolean debugStep;


	/** Constructor initializing the VM such that it is ready for use.
	 *
	 * Stack and mark pointer are both set to zero, so popping right after
	 * initilization will lead to an exception.
	 *
	 * @param code Array of instructions, generated by ParseUnit.
	 * @param entry Index of the first instruction in the Array.
	 * @param memorySize Number of bytes to allocate for the memory.
	 * */
	public VM(Instruction[] code, int entry, int memorySize)
	{
		this.code = code;
		this.pc = entry;
		this.sp = 0;
		this.mp = 0;
		this.debugStep = false;
		FlowControl.set_PC_id(1);
		StackAccess.set_SP_id(2);
		FrameAccess.set_MP_id(3);
		this.memory = new byte[memorySize];
		this.hangs = false;
	}


	/** Step and execute a single instruction.
	 *
	 * If set, debug output will be printed to stderr.
	 * */
	public void step()
	{
		if (this.debugStep)
		{
			System.err.format(
					"STEP: vm@ %5d [%05d>%5d]  %s%n",
					this.pc, this.mp, this.sp,
					this.code[this.pc].getClass().getName()
					);
		}
		int pcBefore = this.pc;
		this.code[this.pc].execute_with(this);
		this.hangs = (pcBefore == this.pc);
	}


	/** Check whether the VM is still in a runnable state.
	 *
	 * @return True if the next instruction may be executed, false otherwise.
	 * */
	public boolean good()
	{
		return !this.hangs;
	}


	/** Enable or disable step debugging.
	 *
	 * @param debugStep Whether to print debug information on every step or not.
	 * */
	public void set_step_debugging(boolean debugStep)
	{
		this.debugStep = debugStep;
	}


	/** Access to machine state, which is the very same object.
	 * 
	 * @return this.
	 * */
	public MachineState get_state()
	{
		return this;
	}


	/** Access to register file, which is the very same object.
	 *
	 * @return this.
	 * */
	public RegisterFile get_registerfile()
	{
		return this;
	}


	/** Access the memory interface, which is the very same object.
	 *
	 * @return this.
	 * */
	public Memory get_memory()
	{
		return this;
	}


	/** Read memory implementation.
	 *
	 * @see virtualmachine.Memory#read_memory(int,int)
	 * */
	public byte[] read_memory(int position, int num)
	{
		return Arrays.copyOfRange(this.memory, position, position + num);
	}


	/** Write memory implementation.
	 *
	 * @see virtualmachine.Memory#write_memory(int,byte[]);
	 * */
	public void write_memory(int position, byte[] data)
	{
		for (byte b : data)
		{
			this.memory[position] = b;
			position++;
		}
	}


	/** Read register implementation.
	 *
	 * @see virualmachine.RegisterFile#read_register(int)
	 * */
	public int read_register(int id)
	{
		if (id == FlowControl.get_PC_id())
		{
			return this.pc;
		}
		if (id == StackAccess.get_SP_id())
		{
			return this.sp;
		}
		if (id == FrameAccess.get_MP_id())
		{
			return this.mp;
		}
		throw new IllegalArgumentException();
	}


	/** Write register implementation.
	 *
	 * @see virtualmachine.RegisterFile#write_register(int,int)
	 * */
	public void write_register(int id, int data)
	{
		if (id == FlowControl.get_PC_id())
		{
			this.pc = data;
		}
		else if (id == StackAccess.get_SP_id())
		{
			this.sp = data;
		}
		else if (id == FrameAccess.get_MP_id())
		{
			this.mp = data;
		}
		else
		{
			throw new IllegalArgumentException();
		}
	}
}

